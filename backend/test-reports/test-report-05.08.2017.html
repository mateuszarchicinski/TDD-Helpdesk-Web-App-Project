    <section class="suite">
      <h1>Application responses:</h1>
      <dl>
        <section class="suite">
          <h1>GET: /</h1>
          <dl>
            <dt>should returns status code: 200</dt>
            <dd><pre><code>setTimeout(() =&gt; {
    /* eslint-disable */
    request.get(baseUrl, (error, response, body) =&gt; {
        /* eslint-enable */
        if (error) {
            throw error;
        }
        expect(response.statusCode).to.equal(200);
        done();
    });
}, 2500);</code></pre></dd>
            <dt>should returns header with a value of property content-type: text/html; charset=utf-8</dt>
            <dd><pre><code>setTimeout(() =&gt; {
    /* eslint-disable */
    request.get(baseUrl, (error, response, body) =&gt; {
        /* eslint-enable */
        if (error) {
            throw error;
        }
        expect(response.headers['content-type']).to.equal('text/html; charset=utf-8');
        done();
    });
}, 1250);</code></pre></dd>
            <dt>should returns status code 301</dt>
            <dd><pre><code>/* eslint-disable */
request.get({
    url: baseUrl + '///',
    followRedirect: false
}, (error, response, body) =&gt; {
    /* eslint-enable */
    if (error) {
        throw error;
    }
    expect(response.statusCode).to.equal(301);
    done();
});</code></pre></dd>
            <dt>should returns header with a value of property location: http://localhost:5848</dt>
            <dd><pre><code>/* eslint-disable */
request.get({
    url: baseUrl + '///',
    followRedirect: false
}, (error, response, body) =&gt; {
    /* eslint-enable */
    if (error) {
        throw error;
    }
    expect(response.headers.location).to.equal(baseUrl);
    done();
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Application modules:</h1>
      <dl>
        <section class="suite">
          <h1>app.source.js</h1>
          <dl>
            <dt>is an object</dt>
            <dd><pre><code>expect(app).to.be.an('object');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Controllers:</h1>
      <dl>
        <section class="suite">
          <h1>login.js</h1>
          <dl>
            <dt>ctrl without req.body.email/password should call res with status 400 &lt;number&gt; and json {message: &quot;Request body...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>loginController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(400);
expect(resMock.json).to.have.been.calledWith({
    message: 'Request body do not have specified properties email or password.'
});</code></pre></dd>
            <dt>ctrl in case of userModel.find() error should call next(err)</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.find.yields(errorsMock.normal);
loginController(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>ctrl in case of userModel.find() return empty array should call res with status 401 &lt;number&gt; and json {message: &quot;You are...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.find.yields(null, []);
loginController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.unauthorized);</code></pre></dd>
            <dt>ctrl in case of user.comparePasswords() error should call next(err)</dt>
            <dd><pre><code>userMock.errCompare = errorsMock.normal;
reqMock.body = userMock;
userModel.find.yields(null, [userMock]);
loginController(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>ctrl in case of user correct comparing passwords should call res with status 200 &lt;number&gt; and json {firstName: &quot;Aa&quot;, email: &quot;a@a&quot;, password: &quot;aaaaaaaa&quot;} &lt;object&gt;</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.find.yields(null, [userMock]);
loginController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(200);
expect(resMock.json).to.have.been.calledWith(userMock);</code></pre></dd>
            <dt>ctrl in case of user incorrect comparing passwords should call res with status 401 &lt;number&gt; and json {message: &quot;You are...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>reqMock.body = {
    firstName: 'Aa',
    email: 'a@a',
    password: 'wrong_password'
};
userModel.find.yields(null, [userMock]);
loginController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.unauthorized);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Controllers:</h1>
      <dl>
        <section class="suite">
          <h1>logout.js</h1>
          <dl>
            <dt>should remove an active/requested token from user.active_tokens</dt>
            <dd><pre><code>expect(reqMock.user.active_tokens).to.contains('token');
logoutController(reqMock, resMock, nextMock);
expect(reqMock.user.active_tokens).to.not.contains('token');</code></pre></dd>
            <dt>should call once method user.save()</dt>
            <dd><pre><code>logoutController(reqMock, resMock, nextMock);
expect(reqMock.user.save).to.have.been.calledOnce;</code></pre></dd>
            <dt>should call once next(err)</dt>
            <dd><pre><code>reqMock.user.errSave = errorsMock.normal;
logoutController(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledOnce.and.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>should call res with status 204 &lt;number&gt; and end &lt;empty&gt;</dt>
            <dd><pre><code>logoutController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(204);
expect(resMock.end).to.have.been.calledWith();</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Controllers:</h1>
      <dl>
        <section class="suite">
          <h1>main.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(mainController).to.be.a('function');</code></pre></dd>
            <dt>should accept only three arguments</dt>
            <dd><pre><code>expect(mainController.length).to.equal(3);</code></pre></dd>
            <dt>should call function res.send() with default message</dt>
            <dd><pre><code>mainController(reqMock, resMock, nextMock);
expect(resMock.send).to.always.have.been.calledWith('Main Controller: Hello World!');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Controllers:</h1>
      <dl>
        <section class="suite">
          <h1>register.js</h1>
          <dl>
            <dt>ctrl without req.body.firstName/email/password should call res with status 400 &lt;number&gt; and json {message: &quot;Request body...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>registerController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(400);
expect(resMock.json).to.have.been.calledWith({
    message: 'Request body do not have specified properties firstName, email or password.'
});</code></pre></dd>
            <dt>ctrl with invalid req.body properties should call res with status 400 &lt;number&gt; and json {message: err.message} &lt;object&gt;</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.prototype.save.yields(errorsMock.validation);
registerController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(400);
expect(resMock.json).to.have.been.calledWith({
    message: errorsMock.validation.message
});</code></pre></dd>
            <dt>ctrl in case of user.save() error should call next(err)</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.prototype.save.yields(errorsMock.normal);
registerController(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>ctrl with valid req.body properties should call res with status 201 &lt;number&gt; and json {name: &quot;Aa&quot;, email: &quot;a@a&quot;, password: &quot;aaaaaaaa&quot;} &lt;object&gt;</dt>
            <dd><pre><code>reqMock.body = userMock;
userModel.prototype.save.yields(null, userMock);
registerController(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(201);
expect(resMock.json).to.have.been.calledWith(userMock);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Helpers: data-injector.js</h1>
      <dl>
        <section class="suite">
          <h1>Tests with required mongoose connection:</h1>
          <dl>
            <dt>injection of the same data should return an object with property failure &lt;array&gt; which contains duplicate elements in database</dt>
            <dd><pre><code>dataInjector(routeModel, routes).then((results) =&gt; {
    expect(results.failure.length).to.equal(routes.length);
    done();
});</code></pre></dd>
            <dt>injection of new data should return an object with property success &lt;array&gt; which contain newly added elements to database</dt>
            <dd><pre><code>const data = [
    {
        url: '/nowa-trasa0'
    }, {
        url: '/nowa-trasa1'
    }
];
dataInjector(routeModel, data).then((results) =&gt; {
    expect(results.success.length).to.equal(data.length);
    done();
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Tests without required mongoose connection:</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(dataInjector).to.be.a('function');</code></pre></dd>
            <dt>without any arguments should return false</dt>
            <dd><pre><code>dataInjector().catch((err) =&gt; {
    expect(err).to.be.false;
    done();
});</code></pre></dd>
            <dt>without required object property or argument model should return false</dt>
            <dd><pre><code>dataInjector({
    model: null,
    array: routes
}).catch((err) =&gt; {
    expect(err).to.be.false;
    dataInjector(null, routes).catch((err) =&gt; {
        expect(err).to.be.false;
        done();
    });
});</code></pre></dd>
            <dt>without required object property or argument array should return false</dt>
            <dd><pre><code>dataInjector({
    model: routeModel,
    array: null
}).catch((err) =&gt; {
    expect(err).to.be.false;
    dataInjector(routeModel, null).catch((err) =&gt; {
        expect(err).to.be.false;
        done();
    });
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Helpers:</h1>
      <dl>
        <section class="suite">
          <h1>routes-injector.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(routesInjector).to.be.a('function');</code></pre></dd>
            <dt>without any arguments should return false</dt>
            <dd><pre><code>expect(routesInjector()).to.be.false;</code></pre></dd>
            <dt>injection of correct data should return an object with property success &lt;array&gt; which contains newly added routes to application</dt>
            <dd><pre><code>expect(routesInjector(app, routes).success.length).to.equal(2);</code></pre></dd>
            <dt>injection of incorrect data should return an object with property incorrect &lt;array&gt; which contains incorrect routes</dt>
            <dd><pre><code>expect(routesInjector(app, routes).incorrect.length).to.equal(1);</code></pre></dd>
            <dt>injection of data causing error should return an object with property failure &lt;array&gt; which contains routes with errors</dt>
            <dd><pre><code>expect(routesInjector(app, routes).failure.length).to.equal(2);</code></pre></dd>
            <dt>without required object property or argument appObj should return false</dt>
            <dd><pre><code>expect(routesInjector({
    appObj: null,
    routesArr: routes
})).to.be.false;
expect(routesInjector(null, routes)).to.be.false;</code></pre></dd>
            <dt>without required object property or argument routesArr should return false</dt>
            <dd><pre><code>expect(routesInjector({
    appObj: app,
    routesArr: null
})).to.be.false;
expect(routesInjector(app, null)).to.be.false;</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Middlewares:</h1>
      <dl>
        <section class="suite">
          <h1>default.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(defMiddleware).to.be.a('function');</code></pre></dd>
            <dt>should accept only three arguments</dt>
            <dd><pre><code>expect(defMiddleware.length).to.equal(3);</code></pre></dd>
            <dt>should call function next()</dt>
            <dd><pre><code>expect(nextMock).to.have.been.calledOnce;</code></pre></dd>
            <dt>req.createFullUrl is a function</dt>
            <dd><pre><code>expect(reqMock.createFullUrl).to.be.a('function');</code></pre></dd>
            <dt>req.createFullUrl(path) with path as string or number should return correct url value &lt;string&gt;</dt>
            <dd><pre><code>const stringMock = 'stringMock';
const numberMock = 100;
// environment: unknown
// string
expect(reqMock.createFullUrl(stringMock)).to.equal(`https://localhost-host/${stringMock}`);
// number
expect(reqMock.createFullUrl(numberMock)).to.equal(`https://localhost-host/${numberMock}`);
// both equal
expect(reqMock.createFullUrl(stringMock)).to.equal(reqMock.createFullUrl(`/${stringMock}`));
expect(reqMock.createFullUrl(numberMock)).to.equal(reqMock.createFullUrl(`/${numberMock}`));

// environment: production
process.env.NODE_ENV = 'production';
// string
expect(reqMock.createFullUrl(stringMock)).to.equal(`https://localhost-hostname/${stringMock}`);
// number
expect(reqMock.createFullUrl(numberMock)).to.equal(`https://localhost-hostname/${numberMock}`);
// both equal
expect(reqMock.createFullUrl(stringMock)).to.equal(reqMock.createFullUrl(`/${stringMock}`));
expect(reqMock.createFullUrl(numberMock)).to.equal(reqMock.createFullUrl(`/${numberMock}`));
delete process.env.NODE_ENV;
// is a string
expect(reqMock.createFullUrl(stringMock)).to.be.a('string');</code></pre></dd>
            <dt>res.redirectTo() should call res.redirect(status, path) correctly</dt>
            <dd><pre><code>resMock.redirectTo();
expect(resMock.redirect).to.have.been.calledWith(301, 'https://localhost-host');</code></pre></dd>
            <dt>res.redirectTo(path) should call res.redirect(status, path) correctly</dt>
            <dd><pre><code>resMock.redirectTo('en/dashboard');
expect(resMock.redirect).to.have.been.calledWith(301, 'https://localhost-host/en/dashboard');</code></pre></dd>
            <dt>res.redirectTo(path, status) should call res.redirect(status, path) correctly</dt>
            <dd><pre><code>resMock.redirectTo('/en/dashboard', 302);
expect(resMock.redirect).to.have.been.calledWith(302, 'https://localhost-host/en/dashboard');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Middlewares:</h1>
      <dl>
        <section class="suite">
          <h1>ensureAuthentication.js</h1>
          <dl>
            <dt>without request authorization header should call res with status 401 &lt;number&gt; and json {message: &quot;Please make...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>delete reqMock.headers.authorization;
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith({
    message: 'Please make sure your request has an Authorization header.'
});</code></pre></dd>
            <dt>with authorization token which throws an exception should call res with status 401 &lt;number&gt; and json {message: err.message} &lt;object&gt;</dt>
            <dd><pre><code>tokenHandler.decode.throws(errorsMock.normal);
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>with a not compatible device which sent request to token.payload.device should call res with status 401 &lt;number&gt; and json {message: &quot;You are...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>delete tokenHandlerMock.payload.device;
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.unauthorized);</code></pre></dd>
            <dt>in case of error userModel.find() method should call next(err)</dt>
            <dd><pre><code>userModel.find.yields(errorsMock.normal);
ensureAuthentication(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>in case of no user is found should call res with status 401 &lt;number&gt; and json {message: &quot;You are...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>userModel.find.yields(null, []);
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.unauthorized);</code></pre></dd>
            <dt>with valid and active token should add property user to req</dt>
            <dd><pre><code>userMock.active_tokens.push(tokenHandlerMock.encoded);
tokenHandlerMock.v = true;
userModel.find.yields(null, [userMock]);
ensureAuthentication(reqMock, resMock, nextMock);
expect(reqMock.user).to.deep.equal(userMock);</code></pre></dd>
            <dt>in case of expired or inactive token should call res with status 401 &lt;number&gt; and json {message: &quot;Your token...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>userModel.find.yields(null, [userMock]);
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.expires);</code></pre></dd>
            <dt>should remove expired token which is still assigned to user.active_tokens property and call res with status 401 &lt;number&gt; and json {message: &quot;Your token...&quot;} &lt;object&gt;</dt>
            <dd><pre><code>userMock.active_tokens.push(tokenHandlerMock.encoded);
userModel.find.yields(null, [userMock]);
ensureAuthentication(reqMock, resMock, nextMock);
expect(userMock.active_tokens).to.be.empty;
expect(resMock.status).to.have.been.calledWith(401);
expect(resMock.json).to.have.been.calledWith(errorsMock.expires);</code></pre></dd>
            <dt>in case of error user.save() method should call next(err)</dt>
            <dd><pre><code>userMock.active_tokens.push(tokenHandlerMock.encoded);
userMock.errSave = errorsMock.normal;
userModel.find.yields(null, [userMock]);
ensureAuthentication(reqMock, resMock, nextMock);
expect(nextMock).to.have.been.calledWith(errorsMock.normal);</code></pre></dd>
            <dt>in case of ValidationError user.save() method should call res with status 400 &lt;number&gt; and json {message: err.message} &lt;object&gt;</dt>
            <dd><pre><code>userMock.active_tokens.push(tokenHandlerMock.encoded);
userMock.errSave = errorsMock.validation;
userModel.find.yields(null, [userMock]);
ensureAuthentication(reqMock, resMock, nextMock);
expect(resMock.status).to.have.been.calledWith(400);
expect(resMock.json).to.have.been.calledWith({
    message: errorsMock.validation.message
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Middlewares:</h1>
      <dl>
        <section class="suite">
          <h1>language.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(language).to.be.a('function');</code></pre></dd>
            <dt>should accept only three arguments</dt>
            <dd><pre><code>expect(language.length).to.equal(3);</code></pre></dd>
            <dt>should call function next()</dt>
            <dd><pre><code>expect(nextMock).to.have.been.calledOnce;</code></pre></dd>
            <dt>with wrong language param req.lang.value should return default value: pl</dt>
            <dd><pre><code>expect(reqMock.lang.value).to.equal(PAGES_CONFIG.LANGUAGES[0]);</code></pre></dd>
            <dt>with &quot;pl&quot; language param req.lang.value should return &quot;pl&quot;</dt>
            <dd><pre><code>const reqMockPL = nodeMocksHttp.createRequest({
    params: {
        lang: 'pl'
    }
});
language(reqMockPL, resMock, nextMock);
expect(reqMockPL.lang.value).to.equal('pl');</code></pre></dd>
            <dt>with &quot;en&quot; language param req.lang.value should return &quot;en&quot;</dt>
            <dd><pre><code>const reqMockEN = nodeMocksHttp.createRequest({
    params: {
        lang: 'en'
    }
});
language(reqMockEN, resMock, nextMock);
expect(reqMockEN.lang.value).to.equal('en');</code></pre></dd>
            <dt>with any language param req.lang.exist should return true</dt>
            <dd><pre><code>const reqMockANY = nodeMocksHttp.createRequest({
    params: {
        lang: 'plpl'
    }
});
language(reqMockANY, resMock, nextMock);
expect(reqMockANY.lang.exist).to.be.true;</code></pre></dd>
            <dt>without language param req.lang.exist should return false</dt>
            <dd><pre><code>expect(reqMock.lang.exist).to.be.false;</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Middlewares:</h1>
      <dl>
        <section class="suite">
          <h1>middlewares.js</h1>
          <dl>
            <dt>is an instance of an array</dt>
            <dd><pre><code>expect(middlewares).to.be.an.instanceof(Array);</code></pre></dd>
            <dt>an array should contain only functions</dt>
            <dd><pre><code>middlewares.forEach((elem) =&gt; {
                expect(elem).to.be.a('function');
            });</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Models: page.js</h1>
      <dl>
        <section class="suite">
          <h1>Tests with required mongoose connection:</h1>
          <dl>
            <dt>method find should return an array with one object</dt>
            <dd><pre><code>pageModel.find(helpers.PAGE_MODEL.EXAMPLE_DATA, (err, results) =&gt; {
    if (results.length !== 1) {
        throw Error('Something went wrong!');
    }
    done();
});</code></pre></dd>
            <dt class="error">&quot;after each&quot; hook for &quot;method find should return an array with one object&quot;</dt>
            <dd class="error"><pre><code>pageModel.collection.drop().then(() =&gt; {
    done();
});</code></pre></dd>
            <dd class="error">Error: Timeout of 10000ms exceeded. For async tests and hooks, ensure &quot;done()&quot; is called; if returning a Promise, ensure it resolves.</dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Tests without required mongoose connection:</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(pageModel).to.be.a('function');
done();</code></pre></dd>
            <dt>new page object created with all random object properties should return correct object</dt>
            <dd><pre><code>const pageEqual = {
    name: page.name,
    url: page.url,
    statusCode: page.statusCode,
    fileName: page.fileName,
    type: page.type,
    redirect: {
        statusCode: page.redirect.statusCode,
        type: page.redirect.type,
        name: page.redirect.name,
        url: page.redirect.url
    },
    root: page.root
};
expect(pageEqual).to.deep.equal(helpers.PAGE_MODEL.RANDOM_EQUAL_PAGE);</code></pre></dd>
            <dt>method fullUrl should return full url with language param: /pl/test</dt>
            <dd><pre><code>expect(page.fullUrl('pl')).to.equal('/pl/404');</code></pre></dd>
            <dt>method fullFileName should return full file name with language suffix (-pl) and extension (.html): test-pl.html</dt>
            <dd><pre><code>expect(page.fullFileName('pl')).to.equal('404-pl.html');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Models: route.js</h1>
      <dl>
        <section class="suite">
          <h1>Tests with required mongoose connection:</h1>
          <dl>
            <dt>method find should return an array with one object</dt>
            <dd><pre><code>routeModel.find(helpers.ROUTE_MODEL.EXAMPLE_DATA, (err, results) =&gt; {
                if (results.length !== 1) {
                    throw Error('Something went wrong!');
                }
                done();
            });</code></pre></dd>
            <dt>method save on object with the same property url should return an error</dt>
            <dd><pre><code>const route = new routeModel(helpers.ROUTE_MODEL.EXAMPLE_DATA);
/* eslint-disable */
route.save((err, route) =&gt; {
    /* eslint-enable */
    if (!err) {
        throw Error('Something went wrong!');
    }
    done();
});</code></pre></dd>
            <dt>route model constructor without required object property url should return an error</dt>
            <dd><pre><code>/* eslint-disable */
routeModel.create({}, (err, route) =&gt; {
    /* eslint-enable */
    if (!err) {
        throw Error('Something went wrong!');
    }
    done();
});</code></pre></dd>
            <dt>new route object created only with required object property url should return correct object</dt>
            <dd><pre><code>const routeEqual = {
    url: route.url,
    method: route.method,
    controller: route.controller
};
expect(routeEqual).to.deep.equal(helpers.ROUTE_MODEL.EQUAL_ROUTE);</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Tests without required mongoose connection:</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(routeModel).to.be.a('function');</code></pre></dd>
            <dt>new route object created with all random object properties should return correct object</dt>
            <dd><pre><code>const routeEqual = {
    url: route.url,
    method: route.method,
    middlewares: route.middlewares,
    controller: route.controller
};
expect(routeEqual).to.deep.equal(helpers.ROUTE_MODEL.RANDOM_EQUAL_ROUTE);</code></pre></dd>
            <dt>method getMiddlewares should return an array with exported modules function</dt>
            <dd><pre><code>expect(route.getMiddlewares()).to.be.an('array');
route.getMiddlewares().forEach((elem) =&gt; {
    expect(elem).to.be.a('function');
});</code></pre></dd>
            <dt>method getController should return exported module function</dt>
            <dd><pre><code>expect(route.getController()).to.be.a('function');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Models: user.js</h1>
      <dl>
        <section class="suite">
          <h1>Tests with required mongoose connection:</h1>
          <dl>
            <dt>method user.save() should save new user in a database</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA);
/* eslint-disable */
user.save((err, user) =&gt; {
    /* eslint-enable */
    if (err) {
        throw Error(err);
    }
    done();
});</code></pre></dd>
            <dt>method user.save() with user whose email address already exists in a database should return an error</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA);
/* eslint-disable */
user.save((err, user) =&gt; {
    /* eslint-enable */
    if (!err) {
        throw Error(err);
    }
    done();
});</code></pre></dd>
            <dt>method user.comparePassword() with correct password as an argument should return true as the second argument in callback</dt>
            <dd><pre><code>userModel.findOne({
    email: helpers.USER_MODEL.EXAMPLE_DATA.email
}, (err, user) =&gt; {
    user.comparePasswords(helpers.USER_MODEL.EXAMPLE_DATA.password, (err, status) =&gt; {
        expect(status).to.be.true;
        done();
    });
});</code></pre></dd>
            <dt>method user.comparePassword() with wrong password as an argument should return false as the second argument in callback</dt>
            <dd><pre><code>userModel.findOne({
    email: helpers.USER_MODEL.EXAMPLE_DATA.email
}, (err, user) =&gt; {
    user.comparePasswords('wrong_password', (err, status) =&gt; {
        expect(status).to.be.false;
        done();
    });
});</code></pre></dd>
            <dt>new user object should contain properties created and updated</dt>
            <dd><pre><code>userModel.findOne({
    email: helpers.USER_MODEL.EXAMPLE_DATA.email
}, (err, user) =&gt; {
    expect(user).to.have.property('created');
    expect(user).to.have.property('updated');
    done();
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>Tests without required mongoose connection:</h1>
          <dl>
            <dt>new user object should contain all required properties with correct values</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA).toObject();
const userEqual = helpers.USER_MODEL.EXAMPLE_DATA;
userEqual._id = user._id;
expect(user).to.deep.equal(helpers.USER_MODEL.EXAMPLE_DATA);</code></pre></dd>
            <dt>method user.toJSON() should return correct user object with removed password and active_tokens properties</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA).toJSON();
const userEqual = helpers.USER_MODEL.EXAMPLE_DATA;
userEqual._id = user._id;
delete userEqual.password;
delete userEqual.active_tokens;
expect(user).to.deep.equal(userEqual);</code></pre></dd>
            <dt>method user.isActiveToken(token_existing) should return true</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA);
user.active_tokens.push('token');
expect(user.isActiveToken('token')).to.be.true;</code></pre></dd>
            <dt>method user.isActiveToken(token_not_existing) should return false</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA);
expect(user.isActiveToken('token')).to.be.false;</code></pre></dd>
            <dt>method user.removeToken(token) should remove selected token correctly</dt>
            <dd><pre><code>const user = new userModel(helpers.USER_MODEL.EXAMPLE_DATA);
user.active_tokens.push('token');
expect(user.active_tokens).to.contains('token');
user.removeToken('token');
expect(user.active_tokens).to.not.contains('token');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Pages:</h1>
      <dl>
        <section class="suite">
          <h1>pages.js</h1>
          <dl>
            <dt>is an instance of an array</dt>
            <dd><pre><code>expect(pages).to.be.an.instanceof(Array);</code></pre></dd>
            <dt>an array should contain only objects</dt>
            <dd><pre><code>pages.forEach((elem) =&gt; {
                expect(elem).to.be.an('object');
            });</code></pre></dd>
            <dt>each object in an array should have correctly completed properties name, url and fileName</dt>
            <dd><pre><code>pages.forEach((elem) =&gt; {
                expect(elem).to.have.property('name').and.not.to.be.empty;
                expect(elem).to.have.property('url').and.to.match(/^\/{1}[a-z0-9-_]{1,24}$/);
                expect(elem).to.have.property('fileName').and.not.to.be.empty;
            });</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Routes:</h1>
      <dl>
        <section class="suite">
          <h1>routes.js</h1>
          <dl>
            <dt>is an array</dt>
            <dd><pre><code>expect(routes).to.be.an('array');</code></pre></dd>
            <dt>routes &lt;array&gt; should contain only objects</dt>
            <dd><pre><code>routes.forEach((elem) =&gt; {
    expect(elem).to.be.an('object');
});</code></pre></dd>
            <dt>each object in routes &lt;array&gt; should have property url</dt>
            <dd><pre><code>routes.forEach((elem) =&gt; {
    expect(elem).to.have.property('url');
});</code></pre></dd>
            <dt>each object property url in routes &lt;array&gt; should be a string or an array of strings e.g. &quot;/newOne&quot; || [&quot;/newOne&quot;]</dt>
            <dd><pre><code>const regExp = /(^\/{1}[a-z0-9-_:{}*\/]{0,50}$|^\*$)/;
routes.forEach((elem) =&gt; {
    let url = elem.url;
    expect(typeof url === 'string' || url instanceof Array).to.be.true;
    if (typeof url === 'string') {
        expect(url).to.match(regExp);
    }
    if (url instanceof Array) {
        url.forEach((el) =&gt; {
            expect(el).to.match(regExp);
        });
    }
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Services:</h1>
      <dl>
        <section class="suite">
          <h1>alertHandler.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(alertHandler).to.be.a('function');</code></pre></dd>

**~~~~~~~~* INFO LOG - OPEN *~~~~~~~~~**
Remember to specify necessary property type & message in a configuration object or pass arguments in the same order.
**~~~~~~~~* INFO LOG - CLOSE *~~~~~~~~**
            <dt>without any arguments should display a console.log message with info style</dt>
            <dd><pre><code>alertHandler();
expect(console.log).to.always.have.been.calledWith(chalk.blue(messageTemplate('Info', 'Remember to specify necessary property type &amp; message in a configuration object or pass arguments in the same order.')));</code></pre></dd>

**~~~~~~~~* NORMAL TITLE LOG - OPEN *~~~~~~~~~**
Normal message!
**~~~~~~~~* NORMAL TITLE LOG - CLOSE *~~~~~~~~**
            <dt>with specified arguments type: normal, message: Normal message! and title: Normal title should display a console.log message with normal style</dt>
            <dd><pre><code>const type = 'normal';
const message = 'Normal message!';
const title = 'Normal title';
alertHandler(type, message, title);
expect(console.log).to.always.have.been.calledWith(chalk.white(messageTemplate(title, message)));</code></pre></dd>

**~~~~~~~~* SUCCESS TITLE LOG - OPEN *~~~~~~~~~**
Success message!
**~~~~~~~~* SUCCESS TITLE LOG - CLOSE *~~~~~~~~**
            <dt>with specified arguments type: success, message: Success message! and title: Success title should display a console.log message with success style</dt>
            <dd><pre><code>const type = 'success';
const message = 'Success message!';
const title = 'Success title';
alertHandler(type, message, title);
expect(console.log).to.always.have.been.calledWith(chalk.green(messageTemplate(title, message)));</code></pre></dd>

**~~~~~~~~* INFO TITLE LOG - OPEN *~~~~~~~~~**
Info message!
**~~~~~~~~* INFO TITLE LOG - CLOSE *~~~~~~~~**
            <dt>with specified arguments type: info, message: Info message! and title: Info title should display a console.log message with info style</dt>
            <dd><pre><code>const type = 'info';
const message = 'Info message!';
const title = 'Info title';
alertHandler(type, message, title);
expect(console.log).to.always.have.been.calledWith(chalk.blue(messageTemplate(title, message)));</code></pre></dd>

**~~~~~~~~* WARNING TITLE LOG - OPEN *~~~~~~~~~**
Warning message!
**~~~~~~~~* WARNING TITLE LOG - CLOSE *~~~~~~~~**
            <dt>with specified arguments type: warning, message: Warning message! and title: Warning title should display a console.log message with warning style</dt>
            <dd><pre><code>const type = 'warning';
const message = 'Warning message!';
const title = 'Warning title';
alertHandler(type, message, title);
expect(console.log).to.always.have.been.calledWith(chalk.yellow(messageTemplate(title, message)));</code></pre></dd>

**~~~~~~~~* ERROR TITLE LOG - OPEN *~~~~~~~~~**
Error message!
**~~~~~~~~* ERROR TITLE LOG - CLOSE *~~~~~~~~**
            <dt>with specified arguments type: error, message: Error message! and title: Error title should display a console.log message with error style</dt>
            <dd><pre><code>const type = 'error';
const message = 'Error message!';
const title = 'Error title';
alertHandler(type, message, title);
expect(console.log).to.always.have.been.calledWith(chalk.red(messageTemplate(title, message)));</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Services:</h1>
      <dl>
        <section class="suite">
          <h1>mailHandler.js</h1>
          <dl>
            <dt>is a function</dt>
            <dd><pre><code>expect(mailHandler).to.be.a('function');</code></pre></dd>
            <dt>mailHandler() without any arguments should return false</dt>
            <dd><pre><code>mailHandler().then((info) =&gt; {
    /* eslint-disable */
    console.log(info);
    /* eslint-enable */
    done();
}, (err) =&gt; {
    expect(err).to.be.false;
    done();
});</code></pre></dd>
            <dt>mailHandler(config, user) without property type in config object &lt;config.type&gt; should return false</dt>
            <dd><pre><code>mailHandler({}, {}).then((info) =&gt; {
    /* eslint-disable */
    console.log(info);
    /* eslint-enable */
    done();
}, (err) =&gt; {
    expect(err).to.be.false;
    done();
});</code></pre></dd>
            <dt>mailHandler({type: &quot;verification-email&quot;}, {email: &quot;a@a&quot;}) should add to object config properties from, to, subject and html with correct values</dt>
            <dd><pre><code>const user = {
    email: 'a@a'
};
const config = {
    type: 'verification_email'
};
/* eslint-disable */
mailHandler(config, user).catch((err) =&gt; {
    //console.log(err);
});
/* eslint-enable */
expect(config).to.deep.equal({
    type: 'verification_email',
    from: '[Restful API] &lt;admin@mateusz-archicinski.pl&gt;',
    to: 'a@a',
    subject: 'Email verification',
    html: '&lt;p&gt;Verify your email address by clicking on &lt;a href=&quot;undefined/verification/email?token=token&quot;&gt;activate link&lt;/a&gt;.&lt;/p&gt;'
});</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Services:</h1>
      <dl>
        <section class="suite">
          <h1>mongoose.js</h1>
          <dl>
            <dt>is an object</dt>
            <dd><pre><code>expect(mongoose).to.be.an('object');</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Services:</h1>
      <dl>
        <section class="suite">
          <h1>tokenHandler.js</h1>
          <dl>
            <dt>is an object which contains encode and decode methods</dt>
            <dd><pre><code>expect(tokenHandler).to.be.an('object');
expect(tokenHandler.encode).to.be.a('function');
expect(tokenHandler.decode).to.be.a('function');</code></pre></dd>
            <dt>method tokenHandler.encode(subject) should call jwt.encode(payload, secret) once</dt>
            <dd><pre><code>tokenHandler.encode({});
expect(jwt.encode).to.have.been.calledOnce;</code></pre></dd>
            <dt>method tokenHandler.decode(token) should call jwt.decode(token) once</dt>
            <dd><pre><code>try {
    tokenHandler.decode('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJzdWJqZWN0IiwiaWF0IjoxNDk0ODU1OTgxLCJleHAiOjE0OTU0NjA3ODF9.3n7ognYsQRw0n9UirTB8DCpXAzHNYWyutPz92gskVT0');
} catch (err) {
    expect(err.message).to.equal('Signature verification failed');
}</code></pre></dd>
            <dt>method tokenHandler.decode(token) should return an object with the same payload which was encoded in token</dt>
            <dd><pre><code>const encodedToken = tokenHandler.encode(objectMock);
const payload = tokenHandler.decode(encodedToken).payload;
Object.keys(objectMock).forEach((key) =&gt; {
    expect(payload[key]).to.equal(objectMock[key]);
});</code></pre></dd>
            <dt>method of decoded token isValid() should return true</dt>
            <dd><pre><code>const encodedToken = tokenHandler.encode(objectMock);
const isValid = tokenHandler.decode(encodedToken).isValid();
expect(isValid).to.be.true;</code></pre></dd>
            <dt>method of decoded token isValid() should return false</dt>
            <dd><pre><code>sinon.stub(jwt, 'decode').returns({
    exp: 1
});
const encodedToken = tokenHandler.encode(objectMock);
const isValid = tokenHandler.decode(encodedToken).isValid();
expect(isValid).to.be.false;
jwt.decode.restore();</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>
